#pragma once

#include "s_NetGlobal.h"
#include "GLCharData.h"
#include "GLCrowData.h"
#include "GLItem.h"
#include "GLMoney.h"
#include "GLParty.h"
#include "GLPeriod.h"
#include "GLAutoLevel.h"
#include "GLClubMan.h"
#include "GLCDMDefine.h"
//add schoolwars
#include "GLSWDefine.h"
#include "GLSWPDefine.h"
#include "GLRoyalRumbleDefine.h" //Add RoyalRumble Player Define- JADev
#include "GLTowerWarsDefine.h"

//	#include "GLContrlMsg.h"
//	∏ﬁºº¡ÅE¡§∫∏¿« ≈©±‚∏¶ (NET_DATA_BUFSIZE) byte ¿Ã≥ª∑Œ ¡¶«— «œø© º≥∞ÅE
//
#define NET_DELAY		(0.2f)
#define NET_MSGDELAY	(0.3f)

#define MAX_SEARCH_RESULT 10

inline float APPLY_MSGDELAY ( float &fDelay )
{
	fDelay -= NET_MSGDELAY;
	if ( fDelay < 0.0f )	fDelay = 0.0f;
	return fDelay;
}

enum EMGLMSG
{
	EMGLMSG_SKILLMAX	= 100,
	EMGLMSG_COOLTIMEMAX	= 30,
};

enum EMREQUEST_MSG
{
	EMREQMSG_OBJ_DROP	= 0,
};

enum EMTAKE_FB
{
	EMTAKE_FB_OFF				= 0,	//	æ∆¿Ã≈∆¿Ã ªÁ∂Û¡ÅE∞ÊøÅE
	EMTAKE_FB_RESERVED			= 1,	//	øπæÅEº“¿Ø¿⁄∞° ¡ˆ¡§µ«æÅE¿÷¿ª ∞ÊøÅE
	EMTAKE_FB_INVEN_ERROR		= 2,	//	¿Œ∫•≈‰∏Æø° ≥÷¿ªºÅEæ¯¿Ω.
	EMTAKE_FB_TOO_EVENT_ITEM	= 3,	//	¿ÃπÃ ¿Ã∫•∆Æ æ∆¿Ã≈€¿ª ∞°¡ˆ∞ÅE¿÷Ω¿¥œ¥Ÿ.
	EMTAKE_FB_DISTANCE			= 4,	//	∞≈∏Æ∞° ≥ π´ ∏Ÿ¥œ¥Ÿ.
};

enum EMHOLD_FB
{
	EMHOLD_FB_OFF				= 0,	//	µø¿œ«— æ∆¿Ã≈∆¿Ã ¡∏¡¶«œ¡ÅEæ Ω¿¥œ¥Ÿ.
	EMHOLD_FB_OK				= 1,	//	æ∆¿Ã≈∆¿ª HOLD«’¥œ¥Ÿ.
	EMHOLD_FB_NONKEEPSTORAGE	= 2,	//	∂Ùƒøø° π∞«∞¿ª ≥÷¿ª ºÅEæ¯¿Ω.
};

enum EMCHAR_JOIN_FB
{
	EMCJOIN_FB_ERROR		= 0,
	EMCJOIN_FB_NOWLOGIN		= 1,	//	«ˆ¡¶ ¡¢º”¡ﬂ¿Œ ªÛ≈¬∂Ûº≠ ¡¢º”¿Ã æ»µÀ¥œ¥Ÿ.
	EMCJOIN_FB_PKPOINT		= 2,	//	pk º∫«‚¿Ã ≥Ùæ∆º≠ «ÿ¥ÅE√§≥Œø° ¡¢º” ∫“∞°.
};

enum EMDROP_OUT_FORCED
{
	EMDROPOUT_ERROR			= 0,	//	ø¿∑˘∑Œ ¿Œ«— ¡¢º” ¡æ∑ÅE
	EMDROPOUT_REQLOGIN		= 1,	//	µø¿œ ¿Ø¿˙¿« ¡¢º” Ω√µµ∑Œ ¿Œ«— ¡¢º” ¡æ∑ÅE
};

enum EMCHAR_GATEOUT_FB
{
	EMCHAR_GATEOUT_OK		= 0,
	EMCHAR_GATEOUT_FAIL		= 1,
	EMCHAR_GATEOUT_MAPID	= 2,
	EMCHAR_GATEOUT_GATEID	= 3,
	EMCHAR_GATEOUT_TARMAPID	= 4,
	EMCHAR_GATEOUT_TARGATEID= 5,
	EMCHAR_GATEOUT_FIELDSVR	= 6,
	EMCHAR_GATEOUT_HOLD		= 7,
	EMCHAR_GATEOUT_CONDITION = 8,
	EMCHAR_GATEOUT_CLUBBATTLE = 9,		//	º±µµ¿¸∏ Ω√ ≈¨∑¥πË∆≤
	EMCHAR_GATEOUT_CLUBBATTLE2 = 10,	//	CDM∏ Ω√ ≈¨∑¥πË∆≤
	EMCHAR_GATEOUT_NOPARTY = 11,		//	Add remove party first before entering the map - JADev (JeanArt)
};


enum EMSKILL_LEARNCHECK
{
	EMSKILL_LEARN_OK		= 0,	//	πËøÅEÅEº∫∞ÅE
	EMSKILL_LEARN_MAX		= 1,	//	¥ÅE¿ÃªÅE∑ææ˜¿ª «“ ºÅEæ¯¿Ω.
	EMSKILL_LEARN_NOTTERM	= 2,	//	ø‰±∏ ¡∂∞«¿Ã √Ê¡∑µ«¡ÅEæ æ∆º≠ ∑ææ˜¿ª «“ºÅEæ¯¿Ω.
	EMSKILL_LEARN_NOTCLASS	= 3,	//	∫Œº≠∞° ∆≤∑¡º≠ πËøÅEÅEæ¯Ω¿¥œ¥Ÿ.
	EMSKILL_LEARN_NOTBRIGHT	= 4,	//	∫ÅEæœ ¡∂∞«¿Ã √Ê¡∑µ«¡ÅEæ Ω¿¥œ¥Ÿ.
	EMSKILL_LEARN_ALREADY	= 5,	//	¿ÃπÃ πËøÅEΩ∫≈≥¿‘¥œ¥Ÿ.

	EMSKILL_LEARN_UNKNOWN	= 999
};

enum EMPARTY_LURE_FB
{
	EMPARTY_LURE_OK			= 0,	//	∆ƒ∆º ∏¡˝ø° ºˆ∂ÅE
	EMPARTY_LURE_REFUSE		= 1,	//	∆ƒ∆º ∏¡˝ø° ∞≈∫Œ.
	
	EMPARTY_LURE_FULL		= 2,	//	∆ƒ∆º∞° ∞°µÊ¬˜º≠ ¥ı¿ÃªÅEø¿¿ªºÅEæ¯¿Ω.
	EMPARTY_LURE_OTHER		= 3,	//	¥Ÿ∏• ∆ƒ∆ºø° ∞°¿‘µ«æÅE¿÷æ˚ÿ≠ ∞≈¿˝µ .
	EMPARTY_LURE_OPT		= 4,	//	∆ƒ∆º ø…º« ø¿∑ÅE
	EMPARTY_LURE_OTHERSCHOOL= 5,	//	¥Ÿ∏• «–ø¯ª˝∞˙¿« ∆ƒ∆º ∫“∞°¥….
	EMPARTY_LURE_CLUBBATTLE	= 6,	//	≈¨∑¥πË∆≤ ¡ﬂ¿œ∂ß¥¬ ∆ƒ∆º ∫“∞°
	EMPARTY_LURE_ROYAL_MAP	= 7,//add battle royale
	EMPARTY_LURE_NO_TARGET	= 8,//
};

enum EMTRADE_ANS
{
	EMTRADE_OK				= 0,
	EMTRADE_CANCEL			= 1,
};

enum EMTRADE_AGREE_FB
{
	EMTRADE_AGREE_OK		= 0,
	EMTRADE_AGREE_CANCEL	= 1,
	EMTRADE_AGREE_TIME		= 2,
};

enum EMTRADE_CANCEL_TAR
{
	EMTRADE_CANCEL_NORMAL	= 0,	//	¿œπ›¿˚¿Œ √ÅE“.
	EMTRADE_CANCEL_OTHER	= 1,	//	ªÛ¥ÅE˙‹Ã √ÅE“«‘.
	EMTRADE_CANCEL_MYINVEN	= 2,	//	∞≥∑° µµ¡ﬂ ¿ŒπÅE∫Œ¡∑.
	EMTRADE_CANCEL_TARINVEN	= 3,	//	∞≥∑° µµ¡ﬂ ¿ŒπÅE∫Œ¡∑.
};

enum EMGRINDING_FB
{
	EMGRINDING_FAIL			= 0,
	EMGRINDING_SUCCEED		= 1
};

enum EMGRINDING_RESIST_FB
{
	EMGRINDING_RESIST_FAIL			= 0,
	EMGRINDING_RESIST_SUCCEED		= 1
};
enum EMGRINDING_PERFECT_FB
{
	EMGRINDING_PERFECT_FAIL			= 0,
	EMGRINDING_PERFECT_SUCCEED		= 1
};

enum EMREGEN_GATE_FB
{
	EMREGEN_GATE_FAIL		= 0,
	EMREGEN_GATE_SUCCEED	= 1,
};

enum EMREGEN_CURE_FB
{
	EMREGEN_CURE_FAIL		= 0,
	EMREGEN_CURE_SUCCEED	= 1,
};

enum EMREGEN_CHARRESET_FB
{
	EMREGEN_CHARRESET_SUCCEED	= 0,
	EMREGEN_CHARRESET_FAIL		= 1,
	EMREGEN_CHARRESET_ITEM_FAIL	= 2,
};

enum EMNPC_ITEM_TRADE_FB
{
	EMNPC_ITEM_TRADE_SUCCEED		= 0,
	EMNPC_ITEM_TRADE_FAIL			= 1,
	EMNPC_ITEM_TRADE_ITEM_FAIL		= 2,
	EMNPC_ITEM_TRADE_INSERT_FAIL	= 3,
};

enum EMCONFRONT_FB
{
	EMCONFRONT_FAIL			= 0,	//	¿œπ› ø¿∑ÅE
	EMCONFRONT_AGREE		= 1,	//	¥ÅE√ ºˆ∂ÅE	(ansøÅE
	EMCONFRONT_REFUSE		= 2,	//	¥ÅE√ ∞≈∫Œ.
	EMCONFRONT_OPTION		= 3,	//	ø…º« ø¿∑ÅE
	EMCONFRONT_PEACE		= 4,	//	∆Ú»≠ ¡ˆø™ ¥ÅE√ ∫“∞°.
	EMCONFRONT_MAX			= 5,	//	n πÅE¿ÃªÅEø¨º” ¥ÅE√¿∏∑Œ time ¿Ã»ƒ ¥ÅE√ ∞°¥….
	EMCONFRONT_ELAP			= 6,	//	¡æ¿ÅE¥ÅE√»ƒ time ¿Ã»ƒ ¥ÅE√ ∞°¥….
	EMCONFRONT_ALREADY_ME	= 7,	//	¿⁄Ω≈¿Ã ¿ÃπÃ ¥ÅE√¡ﬂ.
	EMCONFRONT_ALREADY_TAR	= 8,	//	ªÛ¥ÅEÊ¿Ã ¿ÃπÃ ¥ÅE√¡ﬂ.
	EMCONFRONT_PARTY		= 9,	//	∞∞¿∫ ∆ƒ∆ºøÅE≥¢∏Æ¥¬ ¥ÅE√ ∫“∞°.
	EMCONFRONT_DIE_YOU		= 10,	//	ªÛ¥ÅEƒ≥∏Ø≈Õ∞° ¡◊æ˚‹÷æ˚ÿ≠ ¥ÅE√ ∫“∞°.
	EMCONFRONT_DIE_ME		= 11,	//	¿⁄Ω≈¿« ƒ≥∏Ø≈Õ∞° ¡◊æ˚‹÷æ˚ÿ≠ ¥ÅE√ ∫“∞°.

	EMCONFRONT_MENOTPARTY	= 12,	//	∆ƒ∆ºø¯¿Ã æ∆¥œø©º≠ ∆ƒ∆º ¥ÅE√¿Ã ∫“∞°¥….
	EMCONFRONT_MENOTMASTER	= 13,	//	∆ƒ∆º¿Â¿Ã æ∆¥œø©º≠ '∆ƒ∆º¥ÅE√'¿ª Ω≈√ª«œΩ«ºÅEæ¯Ω¿¥œ¥Ÿ.
	EMCONFRONT_TARMASTER	= 14,	//	∆ƒ∆º¿Â¿Ã æ∆¥œø©º≠ '∆ƒ∆º¥ÅE√'¿ª Ω≈√ª«œΩ«ºÅEæ¯Ω¿¥œ¥Ÿ.

	//EMCONFRONT_NO_BET		= 15, //add duel bet
	//EMCONFRONT_CANT_BET		= 16, //add duel bet

	//EMCONFRONT_CANT_BET_MONEY		= 17, //add duel bet
};

enum EMCONFRONT_END
{
	EMCONFRONT_END_FAIL		= 0,	//	¿œπ› ø¿∑ÅE
	EMCONFRONT_END_WIN		= 1,	//	Ω¬∏Æ.
	EMCONFRONT_END_LOSS		= 2,	//	∆–πÅE
	EMCONFRONT_END_TIME		= 3,	//	Ω√∞£ √ ∞ÅE
	EMCONFRONT_END_MOVEMAP	= 4,	//	∏  ¿Ãµø.
	EMCONFRONT_END_DISWIN	= 5,	//	∞≈∏Æ∞° ≥ π´ ∂≥æ˚›ÅE
	EMCONFRONT_END_DISLOSS	= 6,	//	∞≈∏Æ∞° ≥ π´ ∂≥æ˚›ÅE

	EMCONFRONT_END_PARTY	= 7,	//	¥ÅE√ µµ¡ﬂ º≠∑Œ ∆ƒ∆ºø¯¿Ã µ«æ˚ÿ≠ ¡æ∑·µ .

	EMCONFRONT_END_NOTWIN	= 10,	//	Ω¬∏Æø° ±‚ø©«œ¡ÅE∏¯«‘.
	EMCONFRONT_END_PWIN		= 11,	//	∆ƒ∆º¥ÅE√ø° Ω¬∏Æ.
	EMCONFRONT_END_PLOSS	= 12,	//	∆ƒ∆º¥ÅE√ø° ∆–πÅE
	EMCONFRONT_END_PTIME	= 13,	//	∆ƒ∆º¥ÅE√ Ω√∞£√ ∞ÅE

	EMCONFRONT_END_CWIN		= 14,	//	≈¨∑¥¥ÅE√ø° Ω¬∏Æ.
	EMCONFRONT_END_CLOSS	= 15,	//	≈¨∑¥¥ÅE√ø° ∆–πÅE
	EMCONFRONT_END_CTIME	= 16,	//	≈¨∑¥¥ÅE√ Ω√∞£√ ∞ÅE
};

enum EMANTIDISAPPEAR
{
	EMANTIDISAPPEAR_OFF	= 0,		// º“πÊ¡÷ æ¯¿Ω
	EMANTIDISAPPEAR_ON	= 1,		// º“πÊ¡÷ ¬¯øÅE
	EMANTIDISAPPEAR_USE	= 2,		// º“πÊ¡÷ ªÁøÅE
};

// ƒ≥∏Ø≈Õ ∑Œ∫ÅEµΩ∫«√∑π¿ÃøÅEµ•¿Ã≈Õ
struct SCHARINFO_LOBBY
{
	DWORD				m_dwCharID;

	char				m_szName[CHAR_SZNAME];		// ¿Ã∏ß. (∞˙›§)
	EMCHARCLASS			m_emClass;					// ¡˜æÅE (∞˙›§)
	WORD				m_wSchool;					// «–øÅE
	WORD				m_wHair;					// «ÅE˚Ÿ∫≈∏¿œ
	WORD				m_wFace;					// æÛ±º∏æÅE
	WORD                m_wSex;                     // º∫∫∞ (√ﬂ∞°:2005-12-29 Jgkim)
	WORD                m_wHairColor;               // ∏”∏Æ ªˆ±ÅE(√ﬂ∞°:2005-12-29 Jgkim)

	//added by   | 21-6-2012 | Bypass HP+MP+SP
	GLPADATA			m_sHP;						//	ª˝∏˙”Æ. ( «ˆ¡¶/√÷¥ÅEÆ )					//	ª˝∏˙”Æ. ( «ˆ¡¶/√÷¥ÅEÆ )
	GLLLDATA			m_sExperience;				//	∞Ê«Ëƒ°. ( «ˆ¡¶/¥Ÿ¿Ω∑ππÅEµ¥ﬁ∞™ )
	int					m_nBright;					//	º”º∫.

	WORD				m_wLevel;					//	∑π∫ß.
	SCHARSTATS			m_sStats;					//	Stats.

	//add reborn
	int					m_nChaReborn;

	SITEM_LOBY			m_PutOnItems[SLOT_TSIZE];	//	«ÅEÅE¡§∫∏.

	SNATIVEID			m_sSaveMapID;				//	¡æ∑ÅE∏ .

	SCHARINFO_LOBBY () 
		: m_dwCharID(0)
		, m_emClass(GLCC_ARMS_M)
		, m_wLevel(1)
		, m_nChaReborn(0)
		, m_wSchool(0)
		, m_wHair(0)
		, m_wFace(0)
		, m_wSex(0)
		, m_wHairColor(0)
		, m_nBright(0)
	{
		memset(m_szName, 0, sizeof(char) * CHAR_SZNAME);		
	}
};

namespace GLMSG
{
	#pragma pack(1)

	struct SNETPC_BROAD
	{
		NET_MSG_GENERIC		nmg;
		DWORD				dwGaeaID;

		SNETPC_BROAD () 
			: dwGaeaID(0)
		{
		}
	};
	
	struct SNETPK_BROAD
	{
		NET_MSG_GENERIC		nmg;
		DWORD				dwGaeaID;

		SNETPK_BROAD () 
			: dwGaeaID(0)
		{
		}
	};


	struct SNETCROW_BROAD
	{
		NET_MSG_GENERIC		nmg;
		EMCROW				emCrow;
		DWORD				dwID;

		SNETCROW_BROAD () 
			: emCrow(CROW_PC)
			, dwID(0)
		{
		}
	};

	struct SNETPET_BROAD
	{
		NET_MSG_GENERIC		nmg;
		DWORD				dwGUID;

		SNETPET_BROAD () :
			dwGUID(UINT_MAX)
		{
		}
	};

	struct SNET_COMBINE
	{
		enum
		{
			//				√÷¥ÅEÅE€∑Æ    - ( ∏ﬁΩ√¡ÅE«ÅEÅE )
			EMHEAD_SIZE = ( sizeof(NET_MSG_GENERIC) + sizeof(WORD)*2 ),
			EMMAX_SIZE = NET_DATA_BUFSIZE - EMHEAD_SIZE,
		};

		NET_MSG_GENERIC		nmg;
		WORD				wMSG_SIZE;
		WORD				wMSG_CUR;

		BYTE				arrayMSG[EMMAX_SIZE];

		SNET_COMBINE () 
			: wMSG_SIZE(0)
			, wMSG_CUR(0)
		{
			nmg.dwSize = sizeof(SNET_COMBINE);
			nmg.nType = NET_MSG_COMBINE;
			GASSERT(nmg.dwSize<=NET_DATA_BUFSIZE);

			memset(arrayMSG, 0, sizeof(BYTE) * EMMAX_SIZE);
		}

		bool IsVALID ()
		{
			return wMSG_SIZE!=0;
		}

		void RESET ()
		{
			wMSG_SIZE = 0;
			wMSG_CUR = 0;
			memset(arrayMSG, 0, sizeof(BYTE) * EMMAX_SIZE);
		}

		void RESET_CUR ()
		{
			wMSG_CUR = 0;
		}

		bool ADDMSG ( LPVOID _pMsg )
		{
			NET_MSG_GENERIC* pMsg = (NET_MSG_GENERIC*)_pMsg;
			
			//	Note : æ∆¡ÅEµÈæ˚Ã• ∞¯∞£¿Ã ¿÷¥¬¡ÅE¡°∞À.
			//
			WORD wSIZE = (WORD) pMsg->dwSize;
			if ( (wSIZE+wMSG_SIZE) >= EMMAX_SIZE )
			{
				return false;
			}
			else
			{
				//	Note : ∏ﬁΩ√¡ˆ∏¶ µ⁄ø° ≥÷¥¬¥Ÿ.
				//
				memcpy ( arrayMSG+wMSG_SIZE, _pMsg, wSIZE );
				//	Note : ∏ﬁΩ√¡ˆ∞° ¬˜¡ˆ«— ∞¯∞£¿ª ∞ËªÅE
				//
				wMSG_SIZE += wSIZE;
				//	∏ﬁΩ√¡ÅEªÁ¿Ã¡ÅE¿ÅEº≥¡§.
				nmg.dwSize = EMHEAD_SIZE + wMSG_SIZE;	
				return true;
			}
		}

		bool POPMSG ( LPNET_MSG_GENERIC &pMsg )
		{
			if ( wMSG_SIZE<=wMSG_CUR )	return false;

			pMsg = (NET_MSG_GENERIC*) ( arrayMSG + (wMSG_CUR) );
			wMSG_CUR += (WORD) pMsg->dwSize;

			GASSERT(wMSG_SIZE>=wMSG_CUR);
			if ( wMSG_SIZE<wMSG_CUR )	return false;

			return true;
		}
	};

	// Revert to default structure packing
	#pragma pack()
};
